#!/usr/bin/env python
"""
The purpose of this project is to create a command line utility called 
perflogger to measure the performance of commands and other utilities. 
This module will capture run time environment and performance data from 
outputs of commands that have been run with this module. Information will 
be parsed into a JSON document and inserted into an index in the Elasticsearch 
database using the Python Elasticsearch Client. With the performance data in 
the Elasticsearch database, further exploration and analysis on the data can 
be done on Kibana, which is a data visualization plugin for Elasticsearch.
"""
import time
import sys
import argparse
import logging
import subprocess
import os
import platform

from perflogger import Perf


def parseArguments():
    parser = argparse.ArgumentParser(
            usage = 'perflogger [-h] [-d] [-p PROJECT] [--mpirun] \
                    [-np NP] command [command options] [command args]',
            formatter_class=argparse.RawDescriptionHelpFormatter,
            description=__doc__)
    parser.add_argument("command", type=str, nargs="+",
            help="command to run with additional options and arguments")
    parser.add_argument('-d', "--debugging", action='store_true', 
            default=False, help="print detailed debugging information")
    parser.add_argument('-p', "--project",
            help="the project that the command is being run for")
    parser.add_argument('--mpirun', default=False, action='store_true',
            help="Run the command with MPI")
    parser.add_argument('-np', default=1, type=int, 
            help="Number of processes to tell commands to use")

    return parser.parse_known_args()


def runCommand(args, argv):
    """
    Run the command and get the performance time. 

    Keyword argument:
    -----------------
    command         -- command to be run
    """
    # Run command and get performance data
    if args.mpirun:
        args.command[0:0] = ['mpirun','-np',str(args.np)]
    runCommand = ' '.join(args.command + argv)
    startTS = time.ctime() # Start Timestamp
    start = time.time()
    p = subprocess.Popen(runCommand, stdout=subprocess.PIPE, 
            stderr=subprocess.PIPE, shell=True)
    out, err = p.communicate()
    end = time.time()

    endTS = time.ctime() # End Timestamp
    sys.stdout.write(out)
    sys.stderr.write(err)

    isSuccess=True
    if err:
        isSuccess=False

    logging.debug("Command: %s; Output: %s; Error: %s; isSuccess: %s", 
            runCommand, out, err, isSuccess)
    return end - start, startTS, endTS, isSuccess


def main():
    args, argv = parseArguments()
    if args.debugging:
        logging.basicConfig(level=logging.DEBUG, 
                format='%(asctime)s %(message)s',
                datefmt='%I:%M:%S')
    else:
        logging.basicConfig(format='%(asctime)s %(message)s',
                datefmt='%I:%M:%S')
    
    perf = Perf(args, argv)
    cmdResults = runCommand(args, argv)
    perf.setCmdResults(cmdResults)
    esdbJSON = perf.parseToJSON()
    perf.insertToESDB(esdbJSON)

if __name__ == '__main__':
    main()
